# 1.动态规划

动态规划（Dynamic Programming，DP）是一种解决复杂问题的算法思想，适用于具有**重叠子问题**和**最优子结构**的问题。以下是动态规划的详细解析：

---

### **一、什么是动态规划？**
动态规划通过将问题分解为相互重叠的子问题，并存储子问题的解（避免重复计算），从而高效地求解原问题。其核心思想是**记忆化存储**和**递推关系**。

---

### **二、如何识别动态规划问题？**
1. **最优子结构**  
   问题的最优解包含子问题的最优解。例如，最短路径问题中，A→C的最短路径若经过B，则A→B的路径也必须是A→B的最短路径。

2. **重叠子问题**  
   子问题在递归过程中被多次重复计算。例如，斐波那契数列中，计算`fib(5)`需要多次计算`fib(3)`。

3. **典型特征**  
   - 问题要求“最大”“最小”“最长”“最短”等最优解。
   - 问题可分解为多阶段决策，每一步影响后续状态（如背包问题）。

---

### **三、动态规划的解题步骤**
1. **定义状态**  
   明确子问题，用状态表示问题的某个阶段。例如：
   - `dp[i]`：第`i`阶楼梯的爬法数。
   - `dp[i][j]`：字符串A前`i`个字符与字符串B前`j`个字符的编辑距离。

2. **确定状态转移方程**  
   建立子问题之间的关系。例如：
   - 爬楼梯：`dp[i] = dp[i-1] + dp[i-2]`。
   - 最大子数组和：`dp[i] = max(nums[i], dp[i-1] + nums[i])`。

3. **初始化与边界条件**  
   - 初始值：如`dp[0] = 1`（爬楼梯）、`dp[0][j] = j`（编辑距离）。
   - 边界处理：如数组越界、零钱问题中的无法凑出金额。

4. **计算顺序**  
   - **自顶向下**：递归+记忆化（如斐波那契数列的备忘录法）。
   - **自底向上**：迭代填表（常用，更高效）。

5. **优化空间**  
   - 使用滚动数组或一维数组减少空间复杂度（如背包问题的优化）。

---

### **四、经典问题示例**
1. **斐波那契数列**  
   - 状态：`dp[i]`表示第`i`个斐波那契数。
   - 转移：`dp[i] = dp[i-1] + dp[i-2]`，初始`dp[0]=0, dp[1]=1`。

2. **零钱兑换**  
   - 状态：`dp[i]`为凑出金额`i`的最少硬币数。
   - 转移：`dp[i] = min(dp[i - coin] + 1)`，对所有硬币面额`coin`。

3. **最长递增子序列（LIS）**  
   - 状态：`dp[i]`表示以`nums[i]`结尾的LIS长度。
   - 转移：`dp[i] = max(dp[j] + 1)`，对所有`j < i`且`nums[j] < nums[i]`。

---

### **五、动态规划 vs 贪心算法**
- **贪心**：局部最优选择，不可回退（如部分背包问题）。
- **动态规划**：全局最优，保存子问题解，适用于需要遍历所有可能的情况。

---

### **六、实践建议**
1. **从简单问题入手**：如爬楼梯、斐波那契数列，熟悉状态定义与转移。
2. **总结常见模型**：背包问题、序列问题、矩阵路径问题等。
3. **画状态转移表**：通过表格辅助理解递推关系。
4. **注意边界与初始化**：避免因初始值错误导致整体错误。

---

### **七、代码模板（自底向上）**
```python
def dp_solution():
    n = ...  # 问题规模
    dp = [...] * (n+1)  # 初始化状态数组
    dp[0] = ...  # 初始条件
    
    for i in range(1, n+1):
        # 根据状态转移方程计算dp[i]
        dp[i] = ...
    
    return dp[n]
```

---

动态规划就是：给定一个问题，我们把它拆成一个个子问题，知道子问题可以直接解决，然后把子问题的答案保存，以减少重复计算，再根据子问题答案反推，得到原问题解的一般方法。





# 2.单调栈

### **一、什么是单调栈？**
**单调栈（Monotonic Stack）** 是一种特殊的栈结构，栈内的元素始终保持**单调递增或单调递减**的顺序。它并不是一种独立的算法，而是一种**数据结构优化技巧**，常用于解决需要快速找到元素“边界”或“极值”的问题。

---

### **二、单调栈的核心思想**
1. **维护单调性**：在元素入栈时，通过调整栈内元素，保持栈的单调性（递增或递减）。
2. **快速定位边界**：利用单调性，可以在 O(1) 或 O(n) 时间内找到某个元素的前后更大（或更小）元素。

---

### **三、单调栈的典型应用场景**
#### **1. 下一个更大元素（Next Greater Element）**
**问题**：给定数组 `[2, 1, 5, 6, 2, 3]`，为每个元素找到右侧第一个比它大的数。  
**答案**：`[5, 5, 6, -1, 3, -1]`  
**单调栈解法**：
- 使用**递减栈**（栈顶到栈底单调递减）。
- 遍历数组，若当前元素 > 栈顶元素，则栈顶元素的下一个更大元素就是当前元素。
- **动画演示**：
  ```
  初始栈：空
  遍历元素 2 → 入栈 → 栈：[2]
  遍历元素 1 < 2 → 入栈 → 栈：[2, 1]
  遍历元素 5 > 1 → 弹出1 → 记录1的下一个更大是5
              5 > 2 → 弹出2 → 记录2的下一个更大是5 → 入栈5 → 栈：[5]
  遍历元素6 >5 → 弹出5 → 记录5的下一个更大是6 → 入栈6 → 栈：[6]
  遍历元素2 <6 → 入栈 → 栈：[6, 2]
  遍历元素3 >2 → 弹出2 → 记录2的下一个更大是3 → 入栈3 → 栈：[6,3]
  ```

#### **2. 柱状图中的最大矩形（LeetCode 84）**
**问题**：给定柱状图高度数组 `[2,1,5,6,2,3]`，求能勾勒出的最大矩形面积。  
**单调栈解法**：
- 维护一个**递增栈**（栈顶到栈底单调递增）。
- 遍历每个柱子高度，若当前高度 < 栈顶高度，则计算以栈顶高度为高的矩形面积。
- **时间复杂度**：O(n)（每个元素入栈、出栈一次）。

---

### **四、单调栈的两种类型**
| **类型**       | **单调性**         | **典型问题**                  |
| -------------- | ------------------ | ----------------------------- |
| **单调递增栈** | 栈顶到栈底元素递增 | 寻找左侧/右侧第一个更小的元素 |
| **单调递减栈** | 栈顶到栈底元素递减 | 寻找左侧/右侧第一个更大的元素 |

---

### **五、为什么用单调栈？**
#### **暴力解法的缺陷**
以“下一个更大元素”为例，暴力解法需要两层循环遍历，时间复杂度为 **O(n²)**。  
**单调栈优化**：通过维护单调性，将时间复杂度降低到 **O(n)**。

---

### **六、单调栈的代码模板（以递减栈为例）**
```python
def next_greater_element(nums):
    stack = []
    result = [-1] * len(nums)
    for i in range(len(nums)):
        # 当前元素比栈顶元素大 → 弹出栈顶并记录结果
        while stack and nums[i] > nums[stack[-1]]:
            idx = stack.pop()
            result[idx] = nums[i]
        stack.append(i)
    return result
```

---

### **七、经典例题解析**
#### **例题：每日温度（LeetCode 739）**
**问题**：给定温度数组 `[73,74,75,71,69,72,76,73]`，求需要等待多少天才能有更高温度。  
**答案**：`[1,1,4,2,1,1,0,0]`  
**单调栈解法**：
- 使用**递减栈**，栈中存储温度下标。
- 遍历数组，若当前温度 > 栈顶温度，则计算天数差并记录结果。

---

### **八、单调栈 vs 动态规划**
| **对比维度**   | **单调栈**                          | **动态规划**                         |
| -------------- | ----------------------------------- | ------------------------------------ |
| **核心思想**   | 通过维护单调性快速找到边界          | 通过记忆化子问题避免重复计算         |
| **适用场景**   | 极值边界问题（如“第一个更大/更小”） | 最优化问题（如最短路径、最大子数组） |
| **时间复杂度** | 通常 O(n)                           | 通常 O(n²) 或 O(n)（优化后）         |

---

### **九、学习建议**
1. **理解单调性的维护逻辑**：手动画图模拟栈的操作（如入栈、出栈、更新结果）。
2. **从简单题入手**：如“下一个更大元素”、“每日温度”。
3. **总结规律**：递增栈用于找更小元素，递减栈用于找更大元素。
4. **练习高频题**：
   - 接雨水（LeetCode 42）
   - 最大矩形（LeetCode 85）
   - 滑动窗口最大值（LeetCode 239）

---

### **十、总结**
单调栈是解决**边界极值问题**的利器，通过维护栈的单调性，将时间复杂度优化到线性级别。它不是一种独立算法，而是一种高效的数据结构使用技巧。掌握其核心逻辑后，可以快速解决多种高频面试题。







# 3.滑动窗口

### **滑动窗口算法详解（附实例拆解）**

---

#### **一、滑动窗口是什么？**
**滑动窗口（Sliding Window）** 是一种通过维护一个动态的“窗口”来处理数组/字符串子区间问题的算法技巧。它通过调整窗口的**左边界**和**右边界**，高效地找到满足特定条件的连续子序列，通常将时间复杂度优化到 **O(n)**。

---

### **二、核心思想**
1. **窗口定义**：用两个指针 `left` 和 `right` 表示窗口的左右边界。
2. **窗口滑动**：
   - **右指针扩张**：探索新元素，尝试满足条件。
   - **左指针收缩**：当窗口不满足条件时，缩小窗口以恢复有效性。
3. **实时更新结果**：在窗口滑动过程中记录最优解。

---

### **三、适用场景**
- **子数组/子字符串问题**：如“最长无重复子串”、“最小覆盖子串”。
- **连续区间统计**：如“和≥target的最短子数组”、“大小为k的最大平均值”。
- **关键词特征**：题目要求“连续”、“最长/最短”、“满足某条件”。

---

### **四、滑动窗口 vs 暴力解法**
以“最长无重复字符子串”为例：
- **暴力解法**：遍历所有子串，检查是否重复 → 时间复杂度 **O(n²)**。
- **滑动窗口**：左右指针各遍历一次 → 时间复杂度 **O(n)**。

---

### **五、两种窗口类型**
#### **1. 固定窗口大小**
- **问题示例**：长度为k的子数组的最大平均值。  
- **解法**：窗口大小固定为k，每次滑动右移一位，更新窗口和。  
```python
def max_average(nums, k):
    window_sum = sum(nums[:k])
    max_avg = window_sum / k
    for i in range(k, len(nums)):
        window_sum += nums[i] - nums[i - k]  # 右移窗口
        max_avg = max(max_avg, window_sum / k)
    return max_avg
```

#### **2. 可变窗口大小**
- **问题示例**：无重复字符的最长子串。  
- **解法**：动态调整窗口左右边界，保持窗口内字符唯一。  
```python
def longest_unique_substring(s):
    char_map = {}          # 记录字符最后出现的位置
    left = 0               # 窗口左边界
    max_len = 0
    for right in range(len(s)):
        if s[right] in char_map:
            # 若字符已存在，左边界跳到重复字符的下一位
            left = max(left, char_map[s[right]] + 1)
        char_map[s[right]] = right
        max_len = max(max_len, right - left + 1)
    return max_len
```

---

### **六、经典问题拆解**
#### **例题1：最小覆盖子串（LeetCode 76）**
**问题**：在字符串`s`中找到涵盖字符串`t`所有字符的最短子串。  
**输入**：`s = "ADOBECODEBANC"`, `t = "ABC"` → **输出**：`"BANC"`  
**步骤**：
1. **初始化哈希表**：统计`t`中每个字符的需求量。
2. **滑动窗口遍历**：
   - 右指针扩张，直到窗口包含所有`t`的字符。
   - 左指针收缩，尝试缩小窗口并更新最短长度。
3. **判断覆盖条件**：通过计数器检查是否满足所有字符需求。  

```python
def min_window(s, t):
    from collections import defaultdict
    need = defaultdict(int)
    for c in t:
        need[c] += 1
    left = 0
    missing = len(t)  # 剩余需要覆盖的字符数
    min_len = float('inf')
    start = 0
    
    for right in range(len(s)):
        char = s[right]
        if need[char] > 0:
            missing -= 1
        need[char] -= 1
        
        # 当窗口覆盖t时，尝试收缩左边界
        while missing == 0:
            if right - left + 1 < min_len:
                min_len = right - left + 1
                start = left
            # 左移窗口
            left_char = s[left]
            need[left_char] += 1
            if need[left_char] > 0:
                missing += 1
            left += 1
    return s[start:start+min_len] if min_len != float('inf') else ""
```

---

### **七、滑动窗口模板**
```python
def sliding_window(s):
    left = 0        # 窗口左边界
    result = ...    # 结果变量（如最大长度、最短长度）
    counter = ...   # 统计窗口状态（如字符频次、和）
    
    for right in range(len(s)):
        # 更新窗口状态（加入s[right]）
        update(counter, s[right])
        
        # 当窗口不满足条件时，收缩左边界
        while not is_valid(counter):
            # 更新窗口状态（移除s[left]）
            remove(counter, s[left])
            left += 1
        
        # 更新结果（根据窗口的left和right）
        result = update_result(result, right - left + 1)
    
    return result
```

---

### **八、常见陷阱与技巧**
1. **哈希表维护**：使用字典或数组统计窗口内元素（如字符出现次数）。  
2. **边界处理**：右指针遍历到末尾时，左指针可能仍需收缩窗口。  
3. **结果更新时机**：在窗口有效时更新结果（如`while`循环内或外）。  
4. **去重优化**：如“寻找字符串中所有字母异位词”，可用固定窗口快速匹配。

---

### **九、练习建议**
1. **基础题**：  
   - [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)  
   - [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)  
2. **进阶题**：  
   - [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)  
   - [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)  
3. **综合应用**：  
   - [567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)  
   - [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)（需结合单调队列）

---

### **十、总结**
滑动窗口通过**双指针动态调整窗口范围**，将嵌套循环转化为单层循环，是处理连续子区间问题的利器。核心在于：
1. **明确窗口的收缩与扩张条件**  
2. **高效维护窗口状态（哈希表、计数器）**  
3. **在正确时机更新结果**  

掌握模板后，通过经典题目反复练习，可快速识别和解决滑动窗口类问题。





# 4.单调队列

### **单调队列详解与对比单调栈**

---

#### **一、什么是单调队列？**
**单调队列（Monotonic Queue）** 是一种特殊的队列，队列中的元素始终保持**单调递增或单调递减**的顺序。它通过动态调整队头和队尾元素，高效解决需要**快速获取区间极值**的问题（如滑动窗口最大值）。

---

### **二、单调队列的核心思想**
1. **维护单调性**：  
   - 新元素入队时，移除队尾破坏单调性的元素，保证队列整体单调。
2. **淘汰过期元素**：  
   - 当队列头部元素超出当前窗口范围时，将其移除。
3. **快速获取极值**：  
   - 队头元素始终是当前窗口的最大值（递减队列）或最小值（递增队列）。

---

### **三、典型应用场景**
#### **1. 滑动窗口最大值（LeetCode 239）**
**问题**：给定数组 `[1,3,-1,-3,5,3,6,7]` 和窗口大小 `k=3`，返回每个窗口的最大值。  
**答案**：`[3,3,5,5,6,7]`  
**单调队列解法**：  
- 使用**递减队列**（队头到队尾单调递减）。  
- 遍历数组，维护队列中元素的索引，确保队头是当前窗口最大值。  
- 当队头元素超出窗口范围时，移除队头。  

**操作流程**（以窗口 `k=3` 为例）：

| 当前索引 `i` | 当前元素 `nums[i]` | 单调队列（存储索引）   | 窗口范围   | 当前窗口最大值 | 操作说明                                                     |
| :----------- | :----------------- | :--------------------- | :--------- | :------------- | :----------------------------------------------------------- |
| 0            | 1                  | `[0]`                  | 未形成窗口 | -              | 队列空，直接加入索引 0                                       |
| 1            | 3                  | `[1]`                  | 未形成窗口 | -              | 3 > 1（队尾元素值），移除索引 0，加入索引 1                  |
| 2            | -1                 | `[1, 2]`               | [0, 2]     | 3              | -1 < 3，直接加入索引 2。窗口形成，队头索引 1 对应值 3 是最大值 |
| 3            | -3                 | `[1, 2, 3]` → `[2, 3]` | [1, 3]     | 3              | 1. -3 < -1，加入索引 3。 2. 检查队头是否过期：索引 1 < 1（窗口左边界）？否。队头值仍为 3 |
| 4            | 5                  | `[4]`                  | [2, 4]     | 5              | 1. 5 > -3，移除队尾索引 3、2、1（因为它们对应的值均 < 5）。 2. 加入索引 4。 3. 队头索引 4 对应值 5 |
| 5            | 3                  | `[4, 5]`               | [3, 5]     | 5              | 3 < 5，直接加入索引 5。队头索引 4 对应值 5                   |
| 6            | 6                  | `[6]`                  | [4, 6]     | 6              | 1. 6 > 3，移除队尾索引 5、4（因为它们对应的值均 < 6）。 2. 加入索引 6。 3. 队头索引 6 对应值 6 |
| 7            | 7                  | `[7]`                  | [5, 7]     | 7              | 1. 7 > 6，移除队尾索引 6。 2. 加入索引 7。 3. 队头索引 7 对应值 7 |

**最终结果**：`[3, 3, 5, 5, 6, 7]`



### **关键步骤解释**

1. **队列维护规则**：
   - 新元素入队前，从队尾移除所有比它小的元素的索引（保持队列递减）。
   - 检查队头是否在窗口内（`队头索引 >= i - k + 1`），若过期则移除。
2. **窗口范围**：
   - 窗口左边界为 `i - k + 1`（当 `i >= k-1` 时窗口形成）。
3. **最大值来源**：
   - 队列队头索引对应的元素值即为当前窗口最大值。

---

### **四、单调队列 vs 单调栈**
| **对比维度**     | **单调队列**                           | **单调栈**                       |
| ---------------- | -------------------------------------- | -------------------------------- |
| **数据结构特性** | 双端队列（队头、队尾均可操作）         | 栈（仅栈顶操作）                 |
| **核心操作**     | 入队时淘汰队尾元素，出队时淘汰过期元素 | 入栈时淘汰栈顶元素               |
| **适用场景**     | 滑动窗口极值问题（如LeetCode 239）     | 边界极值问题（如下一个更大元素） |
| **时间复杂度**   | 均摊 O(n)                              | 均摊 O(n)                        |
| **典型问题**     | 滑动窗口最大值、队列中的最大值         | 柱状图最大矩形、每日温度         |

---

#### **核心区别总结**  
1. **操作方式**：  
   - 单调队列需要**两端操作**（队头淘汰过期元素，队尾维护单调性）。  
   - 单调栈仅操作**栈顶**。  
2. **应用目标**：  
   - 单调队列关注**动态区间**（如滑动窗口）的极值。  
   - 单调栈关注**静态序列**中元素的边界（如前后第一个更大/更小元素）。  

---

### **五、单调队列的代码模板（以递减队列为例）**
```python
from collections import deque

def max_sliding_window(nums, k):
    q = deque()  # 存储元素索引
    result = []
    for i in range(len(nums)):
        # 移除队尾小于当前元素的索引（维护递减性）
        while q and nums[i] >= nums[q[-1]]:
            q.pop()
        q.append(i)
        
        # 移除超出窗口的队头元素
        while q[0] <= i - k:
            q.popleft()
        
        # 当窗口形成时，记录最大值
        if i >= k - 1:
            result.append(nums[q[0]])
    return result
```

---

### **六、为什么不用堆（优先队列）？**
- **堆的局限性**：  
  堆可以获取极值，但无法高效删除窗口外的过期元素（需遍历堆，时间复杂度高）。  
- **单调队列优势**：  
  通过直接淘汰过期元素和破坏单调性的元素，将时间复杂度优化到 **O(n)**。

---

### **七、经典例题**
#### **例题：队列的最大值（剑指Offer 59-II）**
**问题**：实现一个队列，支持 `push`、`pop` 和 `max` 操作，且所有操作均摊时间复杂度为 O(1)。  
**解法**：  
- 使用一个普通队列存储元素，一个单调递减队列存储最大值候选。  
- `push` 时维护单调队列；`pop` 时若元素是当前最大值，同步弹出单调队列队头。



---

### **总结**
单调队列通过**维护队列单调性**和**淘汰过期元素**，高效解决滑动窗口极值问题。与单调栈的核心区别在于**操作方式**和**适用场景**：  
- **单调队列**：动态区间极值 → 滑动窗口、实时数据流。  
- **单调栈**：静态序列边界 → 下一个更大元素、柱状图面积。







# 5.单调队列 vs 单调栈

要判断题目应使用**单调队列**还是**单调栈**，需抓住两者的核心应用场景和操作特性。以下是具体区分方法：

---

### **一、核心区别对比**
| **特征**         | **单调栈**                      | **单调队列**                  |
| ---------------- | ------------------------------- | ----------------------------- |
| **数据结构特性** | 仅操作栈顶（后进先出）          | 双端队列，可操作队头和队尾    |
| **适用问题类型** | 静态序列的边界极值问题          | 动态窗口/区间的极值问题       |
| **典型操作**     | 找元素的前后第一个更大/更小元素 | 维护滑动窗口内的最大值/最小值 |
| **时间复杂度**   | 均摊 O(n)                       | 均摊 O(n)                     |

---

### **二、题目特征与判断方法**
#### **1. 优先考虑单调栈的题目特征**
- **问题关键词**：  
  - **“下一个更大元素”**（如 LeetCode 496）  
  - **“柱状图中最大矩形”**（如 LeetCode 84）  
  - **“每日温度”**（如 LeetCode 739）  
- **关键条件**：  
  - 需要找到某个元素在序列中的**前驱或后继极值边界**（如左侧第一个更小的数）。  
  - 数据是**静态序列**，不需要动态维护窗口。  

**示例**：  
题目：给定数组 `[2,1,2,4,3]`，求每个元素右侧第一个更大的数。  
答案：`[4,2,4,-1,-1]`  
**解法**：用单调递减栈，遍历时弹出比当前元素小的栈顶元素。

---

#### **2. 优先考虑单调队列的题目特征**
- **问题关键词**：  
  - **“滑动窗口最大值”**（如 LeetCode 239）  
  - **“队列中的最大值”**（如 剑指Offer 59-II）  
  - **“最长连续子数组的绝对差限制”**（如 LeetCode 1438）  
- **关键条件**：  
  - 需要维护一个**动态区间（窗口）内的极值**（如窗口中的最大值）。  
  - 数据是**动态变化的**，窗口范围随指针移动而变化。  

**示例**：  
题目：给定数组 `[1,3,-1,-3,5,3,6,7]` 和窗口大小 `k=3`，返回每个窗口的最大值。  
答案：`[3,3,5,5,6,7]`  
**解法**：用单调递减队列，维护队头为当前窗口最大值，淘汰过期元素。

---

### **三、快速判断步骤**
1. **判断是否涉及滑动窗口**：  
   - 若题目要求处理**固定或可变长度的连续子区间**，且需要快速获取区间极值 → **单调队列**。  
   - 若问题针对**整个序列中的元素边界**（如前后第一个更大值） → **单调栈**。

2. **观察是否需要淘汰过期元素**：  
   - 单调队列需要处理**窗口移动时元素的过期问题**（如滑动窗口左边界移动）。  
   - 单调栈处理的元素是**全局的**，无需考虑过期。

3. **分析是否需要两端操作**：  
   - 单调队列需同时操作队头和队尾（淘汰过期元素和维护单调性） → **双端队列**。  
   - 单调栈仅操作栈顶 → **普通栈**。

---

### **四、经典题目对照表**
| **题目类型**               | **例题**          | **数据结构** |
| -------------------------- | ----------------- | ------------ |
| 下一个更大元素             | LeetCode 496, 503 | 单调栈       |
| 柱状图中的最大矩形         | LeetCode 84       | 单调栈       |
| 滑动窗口最大值             | LeetCode 239      | 单调队列     |
| 队列中的最大值             | 剑指Offer 59-II   | 单调队列     |
| 绝对差限制的最长连续子数组 | LeetCode 1438     | 单调队列×2   |

---

### **五、实战技巧**
1. **画图模拟**：对问题的手动模拟（如滑动窗口移动、元素入栈出栈）能快速验证思路。  
2. **模板代码对比**：  
   - **单调栈模板**：  
     ```python
     stack = []
     for i in range(len(nums)):
         while stack and nums[i] > nums[stack[-1]]:
             idx = stack.pop()
             # 处理idx与i的关系
         stack.append(i)
     ```
   - **单调队列模板**：  
     ```python
     from collections import deque
     q = deque()
     for i in range(len(nums)):
         while q and nums[i] > nums[q[-1]]:
             q.pop()
         q.append(i)
         while q[0] <= i - k:  # 淘汰过期元素
             q.popleft()
     ```

3. **边界条件检查**：  
   - 单调栈注意空栈时的处理（如边界值设为-1）。  
   - 单调队列注意窗口未形成时是否输出结果。

---

### **总结**
- **单调栈**：静态序列，找元素的边界极值（前后更大/更小）。  
- **单调队列**：动态窗口，维护区间内的极值（最大/最小）。  
通过题目中的**滑动窗口需求**和**极值类型**，结合是否需要淘汰过期元素，可快速判断使用哪种结构。